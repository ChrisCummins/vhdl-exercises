;;; safe.asm - Safe unlocking program
;;
;; The program requires the user to enter a 4 digit PIN code by
;; setting the switches to the appropriate digit and then pressing
;; the center key to confirm the digit. Once completed, LED 0 or
;; 1 is set to display whether the user entered the correct
;; code (2013) or not.
;;
;; While functionally similar to the ROM program from coursework
;; 2, this program uses the new instructions implemented in the
;; updated EU, and displays the digits which have been entered on the
;; seven segment display.
;;
;; Generated by http://chriscummins.cc/disassembler and hand-annotated
;; with clearer comments, labels, and directives. Assembly mnemonics
;; based upon AVR instruction set http://www.atmel.com/images/doc0856.pdf.

        ;; Registers.
        ;; =================================================
        .def NULL       r0
        .def PC         r1
        .def SP         r2
        .def SREG       r3

        ;; Device IO.
        ;; =================================================

        ;; Input ports
        .def SWITCHES   0x00
        .def BUTTONS    0x01

        ;; Output ports
        .def LEDS       0x00
        .def SSEG_AN    0x01
        .def SSEG_KA    0x02

        ;; Button masks
        .def BTNU       0x00
        .def BTND       0x10
        .def BTNC       0x20
        .def BTNL       0x40
        .def BTNR       0x80

        ;;; Program data
        .dseg
        .org 0x42

        foo:    .byte 4                 ; RAM[0x42]
        bar:    .byte 20                ; RAM[0x43] to RAM[0x47]
        alice:  .byte 4                 ; RAM[0x48]
        bob:    .byte 4                 ; RAM[0x49]
        cat:    .byte 4                 ; RAM[0x4A]
        dave:   .byte 4                 ; RAM[0x4B]


;;; Program code
;;; ========================================================

        .cseg
        .org 0x08

_main:
        jmp     init

a_digit:
        seto    LEDS, 0x00, 0x88        ; OUT[0] = (OUT[0] & 0x00) ^ 0x88
        call    c_button_toggle
        tsti    0x00, 0xF0, 0x20        ; Switch 2 high
        brts    a_digit_correct         ; Branch to 0x00000E if SR[T] set
        jmp     a_digit_incorrect       ; Jump to 0x000022
a_digit_correct:
        seto    LEDS, 0x0F, 0x40        ; OUT[0] = (OUT[0] & 0x0F) ^ 0x40
        call    c_button_toggle
        tsti    0x00, 0xF0, 0x00        ; All switches off
        brts    b_digit_correct         ; Branch to 0x000013 if SR[T] set
        jmp     b_digit_incorrect       ; Jump to 0x000024
b_digit_correct:
        seto    LEDS, 0x0F, 0x20        ; OUT[0] = (OUT[0] & 0x0F) ^ 0x20
        call    c_button_toggle
        tsti    0x00, 0xF0, 0x10        ; Switch 1 high
        brts    c_digit_correct         ; Branch to 0x000018 if SR[T] set
        jmp     c_digit_incorrect       ; Jump to 0x000026
c_digit_correct:
        seto    LEDS, 0x0F, 0x10        ; OUT[0] = (OUT[0] & 0x0F) ^ 0x10
        call    c_button_toggle
        tsti    0x00, 0xF0, 0x30        ; Switches 1 and 2 high
        brts    d_digit_correct         ; Branch to 0x00001D if SR[T] set
        jmp     d_digit_incorrect       ; Jump to 0x000028
d_digit_correct:
        seto    LEDS, 0x0F, 0x00        ; OUT[0] = (OUT[0] & 0x0F) ^ 0x00
d_digit_correct_confirm:
        tsti    0x01, 0x20, 0x20        ; SR[T] = (OUT[1] & 0x20) ^ 0x20
        brts    d_digit_correct_confirm ; Branch to 0x00001E if SR[T] set
        seto    LEDS, 0x0C, 0x01        ; OUT[0] = (OUT[0] & 0x0C) ^ 0x01
        jmp     reset                   ; Jump to 0x00002C
a_digit_incorrect:
        seto    LEDS, 0x0F, 0x40        ; OUT[0] = (OUT[0] & 0x0F) ^ 0x40
        call    c_button_toggle
b_digit_incorrect:
        seto    LEDS, 0x0F, 0x20        ; OUT[0] = (OUT[0] & 0x0F) ^ 0x20
        call    c_button_toggle
c_digit_incorrect:
        seto    LEDS, 0x0F, 0x10        ; OUT[0] = (OUT[0] & 0x0F) ^ 0x10
        call    c_button_toggle
d_digit_incorrect:
        seto    LEDS, 0x0F, 0x00        ; OUT[0] = (OUT[0] & 0x0F) ^ 0x00
d_digit_incorrect_confirm:
        tsti    0x01, 0x20, 0x20        ; SR[T] = (OUT[1] & 0x20) ^ 0x20
        brts    d_digit_incorrect_confirm ; Branch to 0x000029 if SR[T] set
        seto    LEDS, 0x0C, 0x02        ; OUT[0] = (OUT[0] & 0x0C) ^ 0x02
reset:
        tsti    0x01, 0x40, 0x00        ; SR[T] = (OUT[1] & 0x40) ^ 0x00
        brts    reset                   ; Branch to 0x00002C if SR[T] set
reset_release:
        tsti    0x01, 0x40, 0x40        ; SR[T] = (OUT[1] & 0x40) ^ 0x40
        brts    reset_release           ; Branch to 0x00002E if SR[T] set
        jmp     init                    ; Jump to 0x000054


        ;; Digit confirmation subroutine
c_button_toggle:
        tsti    0x01, 0x20, 0x20        ; Wait until centre button pressed
        brts    c_button_toggle
c_button_release:
        tsti    0x01, 0x20, 0x00        ; Wait until centre button released
        brts    c_button_release
        mtr     r32, foo                ; r32 = foo
        ldil    r33, 0x0008             ; r33L = 0x0008
        imtr    r34, r32, r33           ; r34 = RAM[r32 + r33]
        rtm     r34, foo                ; foo = r34
        ret


        ;; Initialisation routine:
        .org 0x00000054

init:
        sei                             ; Global interrupt enable
        ldil    r32, 0x0048             ; r32L = 0x0048
        rtm     r32, foo                ; foo = r32
        ldil    r32, 0x0020             ; r32L = 0x0020
        rtm     r32, alice              ; alice = r32
        rtm     r32, bob                ; bob = r32
        rtm     r32, cat                ; cat = r32
        rtm     r32, dave               ; dave = r32
        call    test_stack              ; Call 0x000081
        jmp     a_digit                 ; Jump to 0x000009


        .org 0x00000081

test_stack:
        pshr    SP                      ; Push register SP to stack
        popr    NULL                    ; Pop stack to register NULL
        pshr    NULL                    ; Push register NULL to stack
        popr    NULL                    ; Pop stack to register NULL
        pshr    SREG                    ; Push register SREG to stack
        popr    NULL                    ; Pop stack to register NULL
        pshr    r3                      ; Push register r3 to stack
        popr    NULL                    ; Pop stack to register NULL
        ret


;;; Interrupt Routines.
;;; ========================================================

        ;; Interrupt table
        .org 0x00

        jmp     irq0
        jmp     irq1
        reti
        reti
        reti
        reti
        reti
        reti


        ;; Interrupt 0 - toggle LEDs 1 & 2.
        .org 0x00000040

irq0:
        seto    LEDS, 0xFF, 0x0C        ; OUT[0] = (OUT[0] & 0xFF) ^ 0x0C
        reti

        ;; Interrupt 1 - Update seven segment display
        .org    0x90

irq1:
        mtr     r16, bar                ; r16 = RAM[0x000043]
        ldil    r17, 0x0004             ; r17L = 0x0004
        ldil    r18, 0x0008             ; r18L = 0x0008
        imtr    r19, r16, r17           ; r19 = RAM[r16 + r17]
        imtr    r20, r16, r18           ; r20 = RAM[r16 + r18]
        ldil    r21, 0x0060             ; r21L = 0x0060
        imtr    r22, r21, r19           ; r22 = RAM[r21 + r19]
        iotr    r23, 0x00               ; r23 = OUT[0]
        lsr     r24, r23, 4             ; r24 = r23 >> 4
        mtr     r25, foo                ; r25 = foo
        rtim    r25, NULL, r24          ; RAM[NULL + r24] = r25
        rtio    SSEG_AN, r20            ; Seven Segment anodes set
        rtio    SSEG_KA, r22            ; Seven Segment cathodes set
        imtr    r20, r16, NULL          ; r20 = RAM[r16 + NULL]
        rtm     r20, bar                ; RAM[0x000043] = r20
