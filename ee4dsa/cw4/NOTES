USAGE
=====

 TODO

FEATURES
========

 * 2 pass assembler
 * Inspired by AVR syntax / instruction set
 * Recursive macro lookups
 * Recursive file imports
 * Recursive numerical operations

WEAKNESSES
==========

 * Entirely case insensitive
 * No address management of DSEG
 * Single global namespace for all lookups
 * Line orientated
 * Uninformative error messages

DIRECTIVES
==========

.def    name value              Define a symbolic name
.undef  name                    Undeclare a symbolic name
.cseg                           Declares code segment
.dseg                           Declares data segment
.org    address                 Set program origin
.isr    number address          Define an ISR for interrupt number
.input  file                    Import an assembly source

INSTRUCTION SET
===============

OP      ARGS                    ICC     DESC
===================================================================
nop                             1       No operation
halt                            -       Halt process
jmp     address                 1       Jump
rjmp    immediate               1       Jump to relative offset
brts    address                 1       Branch if T flag set
seto    port and xor            1       Set output port
tsti    port and xor            1       Read input port
call    address                 1       Call subroutine
rcall   immediate               1       Call subroutine at relative offset
ret                             2       Return from subroutine
reti                            2       Return from interrupt
sei                             1       Global enable interrupts
cli                             1       Global disable interrupts
ld      reg address             2       Memorty to register
st      reg address             2       Register to memory
ldd     reg reg reg             3       Indexed memory to register
std     reg reg reg             3       Register to indexed memory
pshr    reg                     2       Push
popr    reg                     2       Pop
stio    port reg                2       Register to IO
ldio    reg port                1       IO to register
ldil    reg immediate           2       Load immediate lower
ldiu    reg immediate           2       Load immediate upper
and     reg reg reg             3       Bitwise AND
or      reg reg reg             3       Bitwise OR
xor     reg reg reg             3       Bitwise XOR
lsr     reg reg immediate       3       Logical shift right
lsl     reg reg immediate       3       Logical shift left
equ     reg reg                 3       Equals
neq     reg reg                 3       Not equals
lt      reg reg                 3       Less than
lts     reg reg                 3       Less than Signed
lte     reg reg                 3       Less than or equal
ltes    reg reg                 3       Less than or Equal Signed
gt      reg reg                 3       Greater than
gts     reg reg                 3       Greater Than Signed
gte     reg reg                 3       Greater than or equal
gtes    reg reg                 3       Greather Than or Equal Signed
eqz     reg                     3       Equal zero
nez     reg                     3       Not equal zero
cpy     reg reg                 3       Copy source to dest
clr     reg                     3       Clear bits in register
inc     reg                     3       Increment
incs    reg                     3       Increment Signed
dec     reg                     3       Decrement
decs    reg                     3       Decrement Signed
add     reg reg reg             3       Add
adds    reg reg reg             3       Add Signed
sub     reg reg reg             3       Subtract
subs    reg reg reg             3       Subtract Signed

DATA SEGMENT
============

Syntax:

  <label>: <type> <size>

Where <type>:

      .BYTE
      .WORD

Examples:

  foobar: .BYTE 3

 * Data is aligned to word size

SYMBOLS
=======

Built-ins:

RAM_SIZE        Size of output RAM
IDT_SIZE        Size of interrupt descriptor table
IDT_START       Absolute address of IDT
PROG_START      Absolute address of start of code

LOGICAL OPERATIONS
==================

A + B           Addition
A - B           Subtraction
A & B           Bitwise AND
A | B           Bitwise OR
A ^ B           Bitwise XOR

NUMERICAL MODIFIERS
===================

-A
~A

ISR WITH SWITCH
===============


        .isr 0 irq0
irq0:
        equ     r10, 0reg
        brts    irq0_0
        equ     r10, 1reg
        brts    irq0_1
        equ     r10, 2reg
        brts    irq0_2
        equ     r10, 3reg
        brts    irq0_3
irq0_0:
        mtr     r11, sseg_an_t
        mtr     r12, sseg_ka_t
        rtio    SSEG_AN, r11
        rtio    SSEG_KA, r12
        jmp     irq0_ret
irq0_1:
        mtr     r11, sseg_an_t + 1
        mtr     r12, sseg_ka_t + 1
        rtio    SSEG_AN, r11
        rtio    SSEG_KA, r12
        jmp     irq0_ret
irq0_2:
        mtr     r11, sseg_an_t + 2
        mtr     r12, sseg_ka_t + 2
        rtio    SSEG_AN, r11
        rtio    SSEG_KA, r12
        jmp     irq0_ret
irq0_3:
        mtr     r11, sseg_an_t + 3
        mtr     r12, sseg_ka_t + 3
        rtio    SSEG_AN, r11
        rtio    SSEG_KA, r12
        ldil    r10, 0          ; Reset loop counter
        jmp     irq0_ret
irq0_ret:
        reti
